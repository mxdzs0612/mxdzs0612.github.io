+++
title = "Rust å…¥é—¨å­¦ä¹ ç¬”è®°ï¼ˆä¸‰ï¼‰ï¼šæµç¨‹æ§åˆ¶ä¸å‡½æ•°"
slug = "rust_learn_note_3"
date = 2025-06-28
updated = 2025-06-30
description = "æµç¨‹æ§åˆ¶ï¼Œå¾ªç¯ï¼Œå‡½æ•°ï¼Œå‚æ•°ä¼ é€’ï¼Œå‡½æ•°æ‰€æœ‰æƒï¼Œé«˜çº§å‡½æ•°"
[taxonomies]
tags = ["Rust", "Learn"]
[extra]
pinned = false
post_listing_date = "both"
+++

## æµç¨‹æ§åˆ¶ä¸æ¨¡å¼åŒ¹é…

### æµç¨‹
æ­£å¸¸æƒ…å†µä¸‹ï¼Œä»£ç æ˜¯ä»ä¸Šåˆ°ä¸‹ä¸€è¡Œä¸€è¡Œæ‰§è¡Œçš„ï¼Œä½†æ‰§è¡Œä¸€äº›æ“ä½œä¼šå¯¼è‡´æµç¨‹æ§åˆ¶æ”¹å˜ã€‚

ä¸»æµæµç¨‹æ§åˆ¶ç»“æ„æœ‰ï¼š
- é¡ºåºç»“æ„ï¼šç¨‹åºæŒ‰ä»£ç é¡ºåºä¸€æ­¥ä¸€æ­¥æ‰§è¡Œ
- é€‰æ‹©ç»“æ„ï¼šæ ¹æ®æ¡ä»¶é€‰æ‹©ä¸åŒçš„è·¯å¾„æ‰§è¡Œ
  - if è¯­å¥ï¼šæ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒä»£ç å—
  - switch è¯­å¥ï¼šæ ¹æ®ä¸åŒæ¡ä»¶æ‰§è¡Œä¸åŒä»£ç å—
- å¾ªç¯ç»“æ„ï¼šé‡å¤æ‰§è¡Œä¸€æ®µä»£ç ç›´åˆ°æ»¡è¶³æŸä¸ªæ¡ä»¶ä¸ºæ­¢
  - for
  - while
  - do/while
- è·³è½¬ç»“æ„ï¼šè·³è½¬åˆ°æŒ‡å®šä½ç½®
  - break
  - continue
  - goto

### if
ä»£ç é€è¡Œæ‰§è¡Œï¼Œæ‰§è¡Œæµç¨‹å¯è¢«`if`æ”¹å˜ã€‚

åº”å°½é‡é¿å…è¿‡å¤šåµŒå¥—ä½¿ç”¨ï¼Œä¼šå¯¼è‡´å¯è¯»æ€§é—®é¢˜ã€‚

åŸºæœ¬è¯­æ³•ï¼š
```rust
if condition {
    // do sth
} else {
    // do sth
}
```

### match
Rust ä¸­ï¼Œ`match`ç”¨äºæ¨¡å¼åŒ¹é…ï¼Œå…è®¸æ›´å¤æ‚çš„æ¡ä»¶å’Œåˆ†æ”¯ï¼Œå¯å¤„ç†å¤šä¸ªæ¨¡å¼ï¼Œä¸”å¯ä»¥è¿”å›å€¼ã€‚

åŸºæœ¬è¯­æ³•ï¼š
```rust
match value {
    pattern1 => // æ¨¡å¼1
    pattern2 if condition => // æ¨¡å¼2ä¸” condition ä¸ºçœŸ
    _ => // å…¶ä»–æƒ…å†µ
}
```
ç›¸æ¯”ä¹‹ä¸‹ match æ›´çµæ´»å’Œæ¸…æ™°ï¼Œå¯ç”¨äºæ›´å¤æ‚çš„åœºæ™¯ã€‚

***
### ä¾‹å­
```rust
fn main() {
    let age = 50;
    if age < 50 {
        println!("You are young");
    } else {
        println!("You are old");
    }
    // if çš„è¡¨è¾¾èƒ½åŠ›å¾ˆå¼±ï¼Œä¸ç›´è§‚
    let scores = 70;
    if scores > 90 {
        println!("Good!!!");
    } else if scores > 60 {
        println!("You are OK!");
    } else {
        println!("Bad!!!");
    }
    let msg = if age > 50 { "old" } else { "young" };
    println!("You are {msg}");

    // matchï¼Œå‡½æ•°å¼ç¼–ç¨‹æ€æƒ³
    let num = 90;
    // ç²¾å‡†åŒ¹é…
    match num {
        80 => println!("80"),
        90 => println!("90"),
        _ => println!("Some else"),
    }
    // èŒƒå›´åŒ¹é…
    match num {
        25..=50 => println!("25 ... 50"),
        51..=100 => println!("51 ... 100"),
        _ => println!("Some else"),
    }
    // æˆ–åŒ¹é…
    match num {
        25 | 50 | 75 => print!("25 or 50 or 75"),
        100 | 200 => println!("100 or 200"),
        _ => println!("Some else"),
    }
    // å’Œ if ä¸€èµ·ä½¿ç”¨
    match num {
        x if x < 60 => println!("bad"),
        x if x == 60 => println!("luck"),
        _ => println!("Some else"),
    }
    // èµ‹å€¼
    let num = 60;
    let res = match num {
        x if x < 60 => "bad".to_owned(),
        x if x == 60 => "luck".to_owned(),
        _ => "Some else".to_owned(),
    };
    println!("res value : {res}");
}
```

## å¾ªç¯

### å¾ªç¯ç»“æ„
Rust æä¾›äº†å¦‚ä¸‹å‡ ç§å¾ªç¯ç»“æ„ï¼š
- loopï¼šä¸€ä¸ªæ— é™å¾ªç¯ï¼Œé€šè¿‡`break`ä¸­æ–­
- whileï¼šæ¯æ¬¡å¾ªç¯æ£€æŸ¥æ¡ä»¶ï¼Œæ¡ä»¶ä¸ºçœŸæ—¶æ‰§è¡Œå¾ªç¯ä½“
- forï¼šè¿­ä»£é›†åˆæˆ–èŒƒå›´ï¼Œæ‰§è¡Œä»£ç å¤„ç†æ¯ä¸ªå…ƒç´ 
```rust
for item in iterable {
    // do sth
}
```

### è·³å‡ºå…³é”®å­—
- breakï¼šç«‹å³ç»ˆæ­¢å¾ªç¯å¹¶è·³å‡ºå¾ªç¯ä½“ï¼Œå¯ä»¥é€šè¿‡æ ‡ç­¾çš„æ–¹å¼åœ¨å†…å±‚å¾ªç¯ä½“ä¸­è·³å‡ºå¤–å±‚å¾ªç¯
- continueï¼šç«‹å³è·³è¿‡å½“å‰å¾ªç¯å¹¶å¼€å§‹æ‰§è¡Œä¸‹ä¸€æ¬¡å¾ªç¯

### è¿­ä»£
Rust çš„è¿­ä»£å™¨æ˜¯ä¸€ä¸ªæŠ½è±¡ï¼Œé€šè¿‡å®ç°ä¸€ä¸ª Iterator ç‰¹è´¨ï¼Œæä¾›ç»Ÿä¸€çš„è®¿é—®é›†åˆå…ƒç´ çš„æ–¹å¼ã€‚
```rust
pub trait Iterator {
    type Item;
    fn next (&mut self) -> Option<Self::Item>;
}
```
è¿­ä»£å™¨æä¾›äº†ä¸€ç³»åˆ—ç”¨äºéå†é›†åˆå…ƒç´ çš„æ–¹æ³•ï¼Œå¦‚`next()`ã€`map()`ã€`filter()`ã€‚`for`å¾ªç¯å°±ä¾èµ–äº†è¿­ä»£å™¨çš„`next()`ã€‚

å¾ªç¯æ›´é€‚åˆæ˜ç¡®æ§åˆ¶å¾ªç¯æµç¨‹çš„æƒ…å†µï¼Œè€Œè¿­ä»£å™¨åˆ™æä¾›äº†ä¸€ç§æŠ½è±¡çš„æ–¹å¼æ¥å¤„ç†é›†åˆå…ƒç´ ã€‚

***
### ä¾‹å­
```rust
fn main() {
    // æ— é™å¾ªç¯
    // loop {
    //     println!("Ctrl+C");
    //     std::thread::sleep(std::time::Duration::from_secs(1));
    // }
    let mut i = 0;
    while i < 10 {
        println!("{}", i);
        i += 1;
    }
    println!("for");
    // vec ä¹ŸåŒç†
    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8];
    for element in arr {
        println!("{}", element);
    }
    // é»˜è®¤å·¦é—­å³å¼€
    for i in 0..10 {
        println!("{}", i);
    }
    // ..= è¡¨ç¤ºå³é—­
    for i in 0..=10 {
        println!("{}", i);
    }
    // break
    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    for element in arr {
        if element == 10 {
            break;
        }
        println!("{element}");
    }
    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
    for element in arr {
        // 11 ä¼šæ‰“å°ï¼Œä¸æ‰“å° 10
        if element == 10 {
            continue;
        }
        println!("{element}");
    }
    'outer: loop {
        println!("outer");
        loop {
            println!("inner");
            // break ä¸€ä¸ªæ ‡ç­¾
            break 'outer;
        }
    }

    // å¾ªç¯çš„å†™æ³•
    let numbers = [1, 2, 3, 4, 5];
    let mut for_numbers = Vec::new();
    for &number in numbers.iter() {
        let item = number * number;
        for_numbers.push(item);
    }
    println!("for : {:?}", for_numbers);
    // è¿­ä»£çš„å†™æ³•
    let numbers = [1, 2, 3, 4, 5].to_vec();
    // è¿­ä»£å™¨çš„æ¶ˆè€—å‡½æ•°ï¼Œåç»­ä¼šå±•å¼€
    // å®Œæ•´å†™æ³• let iter_number: Vec<i32> = numbers.iter().map(|&x: i32| x * x).collect();
    let iter_number: Vec<_> = numbers.iter().map(|&x| x * x).collect();
    println!("iter : {:?}", iter_number);
}
```

## å‡½æ•°
å‡½æ•°ç”±`fn`å…³é”®å­—å£°æ˜å’Œå®šä¹‰ã€‚å‡½æ•°å¯ä»¥æ¥å— 0 æˆ–å¤šä¸ªå‚æ•°ï¼Œæ¯ä¸ªå‚æ•°éƒ½è¦æŒ‡å®šç±»å‹ã€‚

å‡½æ•°å¯ä»¥æœ‰æˆ–æ²¡æœ‰è¿”å›å€¼ï¼Œæœ‰è¿”å›å€¼æ—¶ï¼Œé€šè¿‡`->`æŒ‡å®šè¿”å›ç±»å‹ï¼Œå¦åˆ™çœç•¥æˆ–æŒ‡å®šç©ºï¼ˆ`-> ()`ï¼‰ã€‚å‡½æ•°çš„æœ€åä¸€è¡Œå¦‚æœä¸å†™åˆ†å·ï¼Œå…¶ç»“æœå°±ä¼šè¢«å½“ä½œè¿”å›å€¼ï¼Œå¦åˆ™éœ€è¦ç”¨`return`ã€‚

è°ƒç”¨å‡½æ•°éœ€è¦ä½¿ç”¨å‡½æ•°åï¼Œå¹¶ä¼ é€’ç»™å‡½æ•°å…·ä½“çš„å‚æ•°ã€‚

`main`å‡½æ•°æ˜¯ä¸€ä¸ªç‰¹æ®Šå‡½æ•°ï¼Œæ˜¯ç¨‹åºçš„å…¥å£ã€‚

### copy ç‰¹è´¨çš„å‡½æ•°
å¦‚æœæ•°æ®ç±»å‹å®ç°äº†`copy`ç‰¹è´¨ï¼Œåˆ™åœ¨å‡½æ•°ä¼ å‚æ—¶ä¼šå®ç° copy by value æ“ä½œã€‚æ­¤æ—¶ä¼šå°†å®å‚æ‹·è´ä¸ºå½¢å‚ï¼Œå½¢å‚æ”¹å˜ï¼ˆéœ€è¦åŠ `mut`æ‰èƒ½æ”¹å˜ï¼‰ä¸ä¼šå½±å“å®å‚ã€‚

***
### ä¾‹å­
```rust
fn add(x: i32, y: i32) -> i32 {
    x + y
}

fn change_i32(mut x: i32) {
    x = x + 4;
    println!("fn {x}"); // 5
}

fn modify_i32(x: &mut i32) {
    // å€Ÿç”¨å¿…é¡»è§£å¼•ç”¨
    *x += 4;
}

#[derive(Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn print_point(point: Point) {
    println!("point x {}", point.x);
}

fn main() {
    let a = 1;
    let b = 2;
    let c = add(a, b);
    println!("c: {c}"); // 3
    let mut x = 1;
    change_i32(x); // ä¸ä¼šä¿®æ”¹å®å‚
    println!("x {x}"); // 1
    modify_i32(&mut x); // å€Ÿç”¨
    println!("x {x}"); // 5
    let s = Point { x: 1, y: 2 };
    print_point(s); // æ‰€æœ‰æƒå·²ç»æ¶ˆå¤±
    // ç»“æ„ä½“é»˜è®¤æ˜¯ move ï¼Œå¦‚æœä¸åŠ  #[derive(Copy, Clone)]ï¼Œå°±æ— æ³•æ‰“å°äº†
    println!("{}", s.x);
}
```

## å‚æ•°ä¼ é€’

### å‡½æ•°å€¼å‚æ•°ä¼ é€’ move
å‡½æ•°è°ƒç”¨æ—¶ä¼šåœ¨æ ˆä¸Šå¼€è¾Ÿä¸€ä¸ªæ–°çš„æ ˆå¸§ï¼Œç”¨äºå­˜å‚¨å‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‚æ•°å’Œè¿”å›åœ°å€ç­‰ä¿¡æ¯ï¼Œå‡½æ•°ç»“æŸåä¼šé‡Šæ”¾è¯¥ç©ºé—´ã€‚

å½“ä¼ å…¥ non-copy valueï¼ˆå¦‚ Vec Stringï¼‰æ—¶ï¼Œä¼ å…¥å‡½æ•°çš„å®å‚å€¼çš„æ‰€æœ‰æƒä¼šè½¬ç§»åˆ°å½¢å‚ï¼Œå‡½æ•°ç»“æŸæ—¶å°±ä¼šé‡Šæ”¾ã€‚è¯´äººè¯å°±æ˜¯ï¼Œ`move`åªèƒ½ç”¨ä¸€æ¬¡ã€‚

### ä¸å¯å˜å€Ÿç”¨
å€Ÿç”¨å…¶å®å°±æ˜¯å…¶ä»–è¯­è¨€çš„å¼•ç”¨ï¼Œä¸è¿‡åœ¨ rust ä¸­è·å–å˜é‡çš„å¼•ç”¨ä¸€èˆ¬å«å€Ÿç”¨ã€‚

å¦‚æœä¸æƒ³å¤±å»å€¼çš„æ‰€æœ‰æƒï¼Œåˆæ²¡æœ‰ä¿®æ”¹éœ€æ±‚ï¼Œå°±å¯ä»¥ä½¿ç”¨ä¸å¯å˜å€Ÿç”¨ã€‚

ä¸å¯å˜å¼•ç”¨å¯ä»¥ä½œä¸ºå‡½æ•°çš„å‚æ•°ï¼Œä»è€Œåœ¨å‡½æ•°å†…éƒ¨è®¿é—®å‚æ•°å€¼ï¼ŒåŒæ—¶ä¸èƒ½ä¿®æ”¹ã€‚è¿™è¿™æœ‰åŠ©äºç¡®ä¿æ•°æ®çš„å®‰å…¨æ€§ï¼Œé˜²æ­¢åœ¨å¤šå¤„åŒæ—¶å¯¹æ•°æ®è¿›è¡Œå†™æ“ä½œï¼Œä»è€Œé¿å…æ•°æ®ç«äº‰ã€‚

ä½¿ç”¨ä¸å¯å˜å€Ÿç”¨éœ€è¦ä½¿ç”¨`*`è§£å¼•ç”¨ï¼ˆdeferenceï¼‰ï¼Œæ¥è·å–å€¼ã€‚

### å¯å˜å€Ÿç”¨
å¯å˜å€Ÿç”¨å…è®¸åœ¨å‡½æ•°å†…éƒ¨ä¿®æ”¹å‚æ•°çš„å€¼ï¼Œæ‰§è¡Œå†™æ“ä½œã€‚åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚

éœ€è¦æ‰‹åŠ¨åœ¨å½¢å‚å‰åŠ `&mut`ï¼ŒåŒæ ·éœ€è¦ä½¿ç”¨`*`è§£å¼•ç”¨ã€‚

***
### ä¾‹å­
```rust
fn move_func(p1: i32, p2: String) {
    println!("p1 is {}", p1);
    println!("p2 is {}", p2);
}

// borrow
fn print_value(value: &i32) {
    // ä¸åŠ  * ä¹Ÿå¯ä»¥ï¼Œé»˜è®¤è§£å¼•ç”¨
    println!("{}", value);
}

fn string_func_borrow(s: &String) {
    // println!("{}", s); // è¿™ä¹ˆå†™ä¹Ÿæ˜¯å¯ä»¥çš„
    println!("{}", (*s).to_uppercase());
}

// ç»“æ„ä½“æ²¡æœ‰å®ç° display ç‰¹è´¨ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ªè‡ªåŠ¨å®ç°çš„ debug ç‰¹è´¨
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn modify_point(point: &mut Point) {
    (*point).x += 2;
    point.y += 2;
}

fn main() {
    let n = 12;
    let s = String::from("oo");
    move_func(n, s);
    // n åšäº† copy, s åšäº† move
    println!("n is {}", n);
    // println!("s is {}", s);
    let s = String::from("oo");
    // ä¿ç•™æ‰€æœ‰æƒï¼Œéœ€è¦ä¸å¯å˜å€Ÿç”¨
    print_value(&n);
    print_value(&n);
    string_func_borrow(&s);
    println!("n is {} s is {}", n, s);
    let mut p = Point { x: 0, y: 0 };
    // :? æ˜¯ debug ç‰¹è´¨çš„æ‰“å°æ–¹å¼ï¼Œæ²¡æœ‰å®ç° display ç‰¹è´¨æ—¶æ— æ³•ä½¿ç”¨ {} æ‰“å°ï¼Œåªèƒ½é™çº§ä¸º debug
    println!("{:?}", p);
    modify_point(&mut p);
    println!("{:?}", p);
}
```

## å‡½æ•°è¿”å›å€¼
å‡½æ•°è¿”å›å€¼å¯ä»¥è¿”å›å€¼ç±»å‹ï¼Œä¹Ÿå¯ä»¥è¿”å›å¼•ç”¨ç±»å‹ã€‚

### å€¼ç±»å‹è¿”å›å€¼
å€¼ç±»å‹è¿”å›å€¼æ ¹æ®æ˜¯å¦å®ç°äº† copy åˆ†ä¸ºä¸¤ç§ã€‚copy ç±»å‹çš„å€¼é€šè¿‡å¤åˆ¶è¿›è¡Œè¿”å›ï¼Œé€šå¸¸åœ¨æ ˆä¸Šè¿›è¡Œï¼Œä¸ä¼šæ¶‰åŠå †ä¸Šå†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾ï¼Œå› æ­¤æ›´ä¸ºé«˜æ•ˆã€‚

### è¿”å›å¼•ç”¨
è¿”å›å¼•ç”¨å¾€å¾€éœ€è¦å£°æ˜ç”Ÿå‘½å‘¨æœŸï¼Œé™¤éåªæœ‰ä¸€ä¸ªä¼ å…¥å¼•ç”¨å‚æ•°/ä¸€ä¸ªè¿”å›å¼•ç”¨ã€‚

æ…ç”¨é™æ€ç”Ÿå‘½å‘¨æœŸã€‚

***
### ä¾‹å­
```rust
// åŸºç¡€ç±»å‹å®ç° copy
fn func_copy_back() -> i32 {
    let n = 42;
    n
}

// æ²¡æœ‰å®ç° copyï¼Œæ ˆä¸Šåˆ†é…
fn func_non_copy_back() -> String {
    let s = String::from("hello");
    s
}

// è¿”å› &str éœ€è¦æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œå¦‚æœå®åœ¨ä¸æƒ³æ ‡æ³¨å°±å†™ä¸€ä¸ªé™æ€çš„
fn get_mess(mark: i32) -> &'static str {
    if mark == 0 {
        "ğŸ˜ŠğŸ˜€"
    } else {
        "â‰§ ï¹ â‰¦ğŸ˜«"
    }
}

fn main() {
    let i = func_copy_back();
    println!("{}", i);
    let s = func_non_copy_back();
    println!("{}", s);
    println!("{}", get_mess(i));
}
```

## é«˜é˜¶å‡½æ•°
é«˜é˜¶å‡½æ•°ï¼ˆHigher-Order Functionsï¼‰å°±æ˜¯å‡½æ•°ä½œä¸ºå‡½æ•°çš„å‚æ•°æˆ–è¿”å›å€¼ã€‚è¿™æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„é‡è¦ç‰¹æ€§ã€‚

### è‡ªå®šä¹‰é«˜é˜¶å‡½æ•°
å‡½æ•°å¼ç‰¹æ€§ä¸»è¦æœ‰é—­åŒ…ã€è¿­ä»£å™¨ã€æ¨¡å¼åŒ¹é…ã€æšä¸¾ã€‚å…¶ä¸­æœ‰äº›å·²ç»ä»‹ç»è¿‡ï¼Œå¦å¤–çš„åç»­ç« èŠ‚ä¼šè®²åˆ°ã€‚

### é›†åˆçš„é«˜é˜¶å‡½æ•°
- mapï¼šå¯¹é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ åº”ç”¨ä¸€ä¸ªå‡½æ•°ï¼Œå¹¶è¿”å›åŒ…å«ç»“æœçš„æ–°é›†åˆã€‚
- filterï¼šæ ¹æ®è°“è¯çš„ç»“æœæ˜¯å¦ä¸ºçœŸè¿‡æ»¤é›†åˆä¸­çš„å…ƒç´ 
- fold/reduceï¼šè¿­ä»£é›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶å°†å…¶ç§¯ç´¯åˆ°ä¸€ä¸ªå•ä¸€ç»“æœä¸­

***
### ä¾‹å­
```rust
fn func_twice(f: fn(i32) -> i32, x: i32) -> i32 {
    f(f(x))
}

fn mul(x: i32) -> i32 {
    x * x
}

fn add(x: i32) -> i32 {
    x + 10
}

fn main() {
    let result = func_twice(mul, 4);
    println!("{result}"); // 256
    let res = func_twice(add, 10);
    println!("{res}"); // 30
    // æ•°å­¦è®¡ç®—
    let numbers = vec![1, 2, 3, 4, 5, 6, 7]; // Vec<i32>
    // å†™æˆ map(|x| x + x) ä¹Ÿèƒ½é€šè¿‡ç¼–è¯‘å™¨æ£€æŸ¥ï¼Œx è¢«è‡ªåŠ¨æ¨å¯¼ä¸º &i32
    let res: Vec<_> = numbers.iter().map(|&x| x + x).collect();
    println!("{:?}", res);

    let numbers = vec![1, 2, 3, 4, 5, 6, 7];
    // ref ref_mut move
    let evens = numbers
    // into_iter æ˜¯å¦ä¸€ç§åˆ›å»ºè¿­ä»£å™¨çš„æ–¹å¼
    // è¿­ä»£å™¨ä¹Ÿæœ‰ ref ref_mut moveï¼Œåç»­ä¼šå±•å¼€
        .into_iter()
        .filter(|&x| x % 2 == 0)
        .collect::<Vec<_>>();
    println!("{:?}", evens);

    let numbers = vec![1, 2, 3, 4, 5, 6, 7]; // æ³¨æ„ä¸Šä¸€ä¸ª numbers çš„æ‰€æœ‰æƒæ­¤æ—¶å·²ç»æ²¡äº†ï¼Œéœ€è¦é‡æ–°åˆ›å»º
    // fold éœ€è¦ä¼ å…¥åˆå§‹å€¼å’Œè¦æ‰§è¡Œçš„èšåˆæ“ä½œã€‚å…¶å®å°±æ˜¯ map reduce çš„ reduce
    let sum = numbers.iter().fold(0, |acc, &x| acc + x);
    println!("Sum: {}", sum);
}
```
